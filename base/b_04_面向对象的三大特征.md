# 面向对象三大特征

---

## 1. 封装

封装就是将成员变量、成员方法等隐藏起来，防止该类的的信息被其他类随意访问。要访问该数据必须通过指定的方式。适当的封装可以让代码更容易理解和维护，也增强了代码的安全性。<br />封装在Java程序中体现在：

   1. 方法就是一种封装；
   1. 关键字private也是一种封装。

### 1.2. 封装的原则

将属性隐藏起来，若要访问某个属性，则需要提供公共方法进行访问。

### 1.3. 封装的步骤

1. 使用`private`关键字修饰成员变量；
1. 对需要访问的成员变量，提供以多`getXxx`方法和`setXxx`方法。

### 1.4. 封装的操作-private关键字

#### 1.4.1. private的含义

1. private是一个权限修饰符，代表最小权限；
1. 可以修饰成员变量和成员方法；
1. 被private修饰后，只能在本类中使用；
1. 可以提供getXxx方法和setXxx方法供外界访问。

【注意】基本数据类型中的boolean类型，Getter方法一定要写成isXxx形式，setXxx不变。

#### 1.4.2. private的使用格式

`private 数据类型 变量名;`

### 1.5. 封装的优化

#### 1.5.1. this关键字

使用this关键字，解决形参和成员变量重名的问题。做到见名知意。<br />this关键字代表所在类的当前对象的引用（地址值）。方法被哪个对象调用，this就代表哪个对象。<br />方法的局部变量和成员变量重名时，就近原则优先使用局部变量。使用this可以区分成员变量和局部变量。

`this.成员变量名;`

#### 1.5.2. 构造方法

当一个对象被创建时，使用构造方法来初始化该对象，给对象的成员变量赋初值。

【定义格式】

1. 构造方法名和类名相同；
1. 没有返回值，甚至不需要void。

```java
修饰符 构造方法名() {
	方法体;
}
```

【注意】

   1. Java默认提供无参构造方法；
   1. 自定义了构造方法，则系统不再提供默认的无参构造方法；
   1. 构造方法可以`重载`，可以有参也可以无参。

### 1.6. JavaBean标准类

JavaBean是Java语言编写类的一种标准规范。要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。

1. 所有的成员变量使用private修饰；
1. 每一个成员变量都有Getter和Setter；
1. 具有无参构造方法和全参构造方法。

## 2. 继承

### 2.1. 定义

子类使用 `extends` 关键字继承父类的属性和行为，使子类对象具有与父类相同的属性和行为。子类可以直接访问父类中非私有的属性和行为。如果要访问父类的私有成员变量，则需要使用对应的getXxx和setXxx方法。

### 2.2. 优点

1. 提高代码的复用性；
1. 类与类之间产生了关系，是多态的前提。

### 2.3. 格式

```java
class 父类 {
	//
}

class 子类 extends 父类 {
	//
}
```

### 2.4. 继承的特点

1. Java只支持单继承，不支持多继承；
1. Java支持多层继承（继承体系）；
1. 子类和父类是一种相对的概念。

一个子类只有一个直接父类，但一个父类可以有多个子类。

#### 2.4.1. 成员变量

- 成员变量不重名

    直接访问，没有影响。

- 成员变量重名
  1. 直接通过子类对象访问成员变量
     - 等号左边是谁，就优先使用谁，没有则向上找
  2. 间接通过成员方法访问成员变量
     - 该方法属于谁，就优先用谁，没有则向上找
  3. 使用 `super` 关键字访问父类成员变量
     - 局部变量：直接写变量名
     - 本类成员变量：this.变量名
     - 父类成员变量：super.变量名

#### 2.4.2. 成员方法

- 成员方法不重名

    直接调用，没有影响。

- 成员方法重名
  - [方法重写Override](base/a_09_运算符及方法?id=_34-方法重写override)

    创建（new）的对象是谁，就用谁的方法。如果没有，则向上找父类。<br />【注意】<br />无论是成员变量还是成员方法，如果没有，都是向上找父类，不会向下找子类。

#### 2.4.3. 构造方法

1. 子类无法继承父类的构造；
1. 构造方法的作用是初始化成员变量。所以在子类的初始化过程中，必须先执行父类的初始化动作；
1. 子类构造方法中默认的super()调用父类的无参构造；
1. 可以使用super关键字，子类构造调用父类的重载构造；
1. super父类构造的调用，必须是子类构造方法的第一个语句。只有子类构造才能调用父类构造。

### 2.5. super和this

super：代表父类的存储空间标识（父类引用）<br />this：当前对象的应用

- super关键字的3中用法
  1. 在子类成员方法中，调用父类的成员方法；
  1. 在子类成员方法中，调用父类成员变量；
  1. 在子类构造方法中，调用父类构造方法。
- this关键字的3中用法
  4. 在本类成员方法中，调用本类成员变量；
  4. 在本类成员方法中，调用本类的另一个成员方法；
  4. 在本类构造方法中，访问本类的另一个构造方法。

【注意】

   1. this(...)调用必须是构造方法的第一个语句；
   1. super和this两种构造调用不能同时使用。

## 3. 多态

### 3.1. 概述

> 一个对象的编译类型和运行类型可以不一致；
>
> 编译类型在定义对象时就确定了，不能改变；
>
> 运行类型是可以变化的；
> 
> 编译类型看定义对象时 `=` 的左边，运行类型看 `=` 的右边。

#### 3.1.1 定义

同一行为，具有多个不同的表现形式。

#### 3.1.2. 前提

1. 继承或者实现（二选一）；
1. 方法重写（不重写，则毫无意义）；
1. 父类引用指向子类对象（格式体现）。

#### 3.1.3. 体现

```java
Fu f = new Zi();
f.method();
```

#### 3.2 Java的动态绑定机制

- 调用对象的方法时，该方法会和该对象的 `内存地址/运行类型` 绑定；

- 调用对象对象的属性时，没有动态绑定机制，哪里声明，哪里使用。

### 3.3. 成员访问特点

- 成员方法：编译看左，运行看右
- 成员变量：编译看左，运行看左

### 3.4. 多态优点

实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。<br />无论 `=` 右边 new 的是哪个子类对象， `=` 左边调用的方法都不会变。

### 3.5. 引用类型转换

#### 3.5.1. 向上转型

多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。<br />当父类引用指向一个子类对象时，就是向上转型。

- 格式： `父类名称 对象名 = new 子类名称();` 
- 含义：= 右侧创建一个子类对象，把它当作父类来看待。
- 注意：向上转型一定是安全的。
- 弊端：一旦向上转型为父类，就无法调用子类的特有方法。

#### 3.5.2. 向下转型

父类类型向子类类型向下转换的过程，这个过程是强制的。

- 格式： `子类名称 对象名 = (子类名称) 父类对象;` 
- 含义：将父类对象还原为本来的子类对象。
- 注意：本来是什么子类，才能向下转型为什么子类。

#### 3.5.3. 为什么要转型

当使用多态调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说不能调用子类拥有，而父类没有的方法。所以，如果要调用子类特有的方法，就必须向下转型。

#### 3.5.4. 转型的异常

`ClassCastException` ：类型转换异常（本来是什么子类，才能向下转型为什么子类）。<br />为了避免ClassCastException的发生，Java提供了 `instanceof` 关键字，给引用变量做类型的校验。

#### 3.5.5. instanceof

判断类型：如何才能知道一个父类引用对象，本来是什么类型？

- 格式： `变量名 instanceof 数据类型;` 
  - 得到一个boolean值，判断前面的对象能否作为后面类型的实例。
  - true：该变量属于该数据类型；
  - false：该变量不属于该数据类型。

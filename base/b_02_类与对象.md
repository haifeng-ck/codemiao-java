# 类与对象

---

> 面向对象是一种相对于面向过程的编程思想。这里的对象泛指现实中的一切事物，事物都具备自己的属性和行为。
> 面向对象的思想就是把事物的属性特征和行为特征抽取出来，描述成计算机事件的设计思想。它区别于面向过程的思想，
> 强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。

- 类是一组相关的属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。

- 对象是一类事物的具体体现。对象是类的一个实例，具备该类事物的属性和行为。

## 1. 类的定义

```java
public class 类名{
	成员变量; // 属性
    成员方法; // 行为
}
```

【注意】

   1. 成员变量定义在类中，方法外；
   1. 成员方法前不要写static关键字。
   1. 通常情况下一个类并不能直接使用，需要根据类创建一个对象才能使用。

### 1.1. 成员变量和局部变量的区别

1. 定义位置不同
   - 成员变量：类中，方法外
   - 局部变量：方法内部
2. 作用范围不同
   - 成员变量：类中
   - 局部变量：方法中
3. 初始化值不同
   - 成员变量：有默认初始值（和数组的规则一致）
   - 局部变量：没有默认初始值，必须先定义、赋值，才能使用
4. 内存位置不同
   - 成员变量：堆内存
   - 局部变量：栈内存
5. 生命周期不同
   - 成员变量：随着对象的创建而存在，随着对象的消失而消失
   - 局部变量：随着方法进栈而产生，随着方法出栈而消失

### 1.2. 构造方法

方法名和类名相同，没有返回值，甚至不需要void。

详见：[封装的优化](base/b_04_面向对象的三大特征?id=_152-构造方法)

### 1.3. 代码块

代码块又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，用 `{}` 包裹起来。

代码块在类加载时、或创建对象时隐式调用。

代码块分为两类：被 `static` 修饰的静态代码块、没有修饰符的普通代码块/非静态代码块

代码块优先于构造方法执行。

静态代码块在类加载时执行，且只执行一次；普通代码块在创建对象时执行，每创建一次对象就执行一次，如果只是
使用类的静态成员，普通代码块并不会执行。

### 1.4. 类加载机制

- 类被加载的 3 种情况

    1. 创建对象时（new）；
    2. 创建子类对象时，父类也会被加载，且父类先于子类加载；
    3. 使用类的静态成员时（静态属性、静态方法）。

- 创建对象时，类的调用顺序

    1. 静态代码块和静态属性初始化（如果有多个静态代码块或静态属性，则按定义顺序执行）；
    2. 普通代码块和普通属性初始化（如果有多个普通代码块或普通属性，则按定义顺序执行）；
    3. 构造方法。

## 2. 抽象类

包含[抽象方法](base/a_09_运算符及方法?id=_35-抽象方法)的类。使用`abstract`关键字修饰。<br />`abstract class 类名 {}` <br />【注意】

   1. 不能直接创建（new）抽象类对象；
   1. 必须用一个子类继承抽象父类；
   1. 子类必须重写（实现）父类的所有抽象方法，除非该子类也是一个抽象类；
   1. 使用具体的子类创建对象，调用方法；
   1. 抽象类可以有构造方法，用于子类创建对象时，初始化父类成员；
   1. 抽象类中不一定有抽象方法（适配器模式），有抽象方法的类一定是抽象类。

## 3. 内部类

一个类A定义在另一个类B内部，内部的类A就称为内部类，外部的类B则称为外部类。<br />内部类分为：成员内部类和局部内部类，局部内部类包括匿名内部类。<br />内部类是一个独立的类，会被编译成独立的.class文件，但是文件名为：外部类名$内部类名.class。如：Human$Heart.class

- 内部类权限修饰符使用规则
  - 外部类：public / default
  - 成员内部类：public / protected / default / private
  - 局部内部类：不能使用权限修饰符，只能在本方法中使用。

### 3.1. 成员内部类

定义在类中方法外的类。

```java
修饰符 class 外部类名称 {
	修饰符 class 内部类名称 {
    	//
    }
}
```

- 访问特点
  - 内部类可以直接访问外部类的成员，包括私有成员；
  - 外部类要访问内部类的成员，则必须创建内部类对象；
  - 间接访问：在外部类的方法中访问内部类，然后调用外部类的方法即可访问内部类的成员；
  - 直接访问：直接创建内部类对象访问。
- 创建内部类对象的格式：使用外部类对象创建内部类对象

    `外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();` <br />
    【注意】<br />
    内部类与外部类成员变量同名时访问外部类的成员变量：<br />
    `外部类名称.this.外部类成员变量名`

- 示例

```java
package com.junlong.man;

/**
 * @Author: junlong.zhou
 * @Date: 2021/6/25 17:53
 * @Version 1.0
 */
public class Human {
    private boolean live = false; // 存活状态

    // 心脏成员内部类
    class Heart {
        private boolean live = false; // 内部类成员变量
        // 心脏跳动
        public void jump() {
            // 内部类成员变量和外部类成员变量同名，访问外部类成员变量格式：外部类名.this.外部类成员变量名
            if (Human.this.live) {
                System.out.println("心脏在跳动...蹦蹦蹦...");
            }else {
                System.out.println("心脏停止跳动！");
            }
        }
    }

    public boolean isLive() {
        return live;
    }

    public void setLive(boolean live) {
        if (live) {
            System.out.println("人工呼吸，救活她♥♥♥");
        }else {
            System.out.println("kill 他💀💀💀");
        }
        this.live = live;
    }
}
```

测试类

```java
package com.junlong.man;

/**
 * @Author: junlong.zhou
 * @Date: 2021/6/25 17:57
 * @Version 1.0
 */
public class test {
    public static void main(String[] args) {
        // 创建外部类对象
        Human human = new Human();
        // 创建内部类对象
        Human.Heart heart = human.new Heart();
        // 调用内部类方法
        heart.jump();
        // 调用外部类方法：活着就kill他，dead就救活她
        human.setLive(!human.isLive());
        // 调用内部类方法
        heart.jump();
    }
}
```

### 3.2. 局部内部类

一个类定义在一个方法内部。

```java
修饰符 class 外部类名称 {
	修饰符 返回值类型 方法名(参数列表) {
    	class 局部内部类名称 {
        	//
        }
    }
}
```

【注意】<br />局部内部类如果想要访问所在方法的局部变量，那么这个局部变量必须是一个有效final的。

   - 原因
     1. new出来的对象在对内存中，等到GC回收才消失；
     1. 局部变量在栈内存，方法执行结束，局部变量则消失。

【备注】<br />jdk8开始，只要局部变量事实不变，那么final关键字可以省略。

### 3.3. 匿名内部类

如果接口的实现类（或者父类的子类）只需要使用一次，那么可以省略该类的定义，使用匿名内部类。<br />匿名内部类的本质是：一个 带具体实现的 父类或者接口的 匿名的 子类对象。

- 前提：匿名内部类必须继承一个父类或者实现一个接口
- 格式

```java
父类或者接口名称 对象名 = new 父类或者接口名称() {
	// 以下是匿名内部类的内容
    // 重写父类或者接口的所有抽象方法
}
```

- 匿名内部类和匿名对象的区别
  1. 匿名内部类创建对象时，只能使用一次；
  1. 匿名内部类省略了子类或者实现类的名称；
  1. 匿名对象调用方法时，只能使用一次；
  1. 匿名对象省略了对象名。
- 使用方式
  - 创建对象使用
  - 方法的形式参数是接口或者抽象类时，可以使用匿名内部类作为参数传递
- 示例

```java
package com.junlong.plan;

/**
 * @Author: junlong.zhou
 * @Date: 2021/6/25 18:28
 * @Version 1.0
 */
public interface Plan {
    void fly();
}
```

```java
package com.junlong.plan;

/**
 * @Author: junlong.zhou
 * @Date: 2021/6/25 18:29
 * @Version 1.0
 */
public class AirBus {
    public static void main(String[] args) {
        // 直接使用匿名内部类创建对象使用
        Plan plan = new Plan() {
            @Override
            public void fly() {
                System.out.println("起飞...");
            }
        };
        plan.fly();

        System.out.println("==================");

        // 使用匿名内部类作为参数
        showFly(new Plan() {
            @Override
            public void fly() {
                System.out.println("我也起飞了.......");
            }
        });
    }

    public static void showFly(Plan plan) {
        plan.fly();
    }
}
```

## 4. 对象（引用类型）的使用

### 4.1. 使用步骤

1. 导包

import 类的全限定名称; // 同一个包下可以不用导包；Java.lang包下的类可以不用导包。

2. 创建对象

`类名 对象名 = new 类名();`

3. 使用
   - 成员变量：`对象名.成员变量;`
   - 成员方法：`对象名.成员方法();`

【注意】

      1. 如果成员变量没有赋值，那么会有一个默认值；

| 整数 | 浮点数 | 字符      | 布尔  | 引用 |
| ---- | ------ | --------- | ----- | ---- |
| 0    | 0.0    | '\\U0000' | false | null |

      1. 使用对象作为方法的参数或返回值，传递的是对象在内存中的地址值。

### 4.2. 对象的内存原理

new出来的对象在堆内存中存储，其成员变量和成员方法自然也在堆内存中。当调用对象的成员方法时，使用对象的方法标记去方法区的class找方法信息执行。

![对象内存原理](https://cdn.jsdelivr.net/gh/haifeng-ck/blogPic/202206272018058.png)

### 4.3. 匿名对象

创建对象时，只有创建对象的语句，没有把对象的地址赋值给某个变量。是创建对象的简化写法，应用场景有限。

【注意】

   1. 创建匿名对象直接调用其方法，没有变量名；
   1. 一个匿名对象只能使用一次；
   1. 匿名对象可以作为方法的参数或返回值。

## 5. 引用类型用法总结

### 5.1. 类作为成员变量

类作为成员变量时，对它进行赋值的操作，实际上是赋给它该类的一个对象。

### 5.2. 接口作为成员变量

接口作为成员变量时，对它进行赋值的操作，实际上是赋给它该接口的一个子类对象。

### 5.3. 接口作为方法的参数或返回值

接口作为方法的参数时，传递它的子类对象；<br />接口作为方法的返回值时，返回它的子类对象。
